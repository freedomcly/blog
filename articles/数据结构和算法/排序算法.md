# 排序算法

| **排序算法** | **时间复杂度** | **描述** |
| :--- | :--- | :--- |
| 冒泡排序 | O(n<sub>2<sub>) |  |
| 插入排序 | O(n<sub>2<sub>) |  |
| 选择排序 | O(n<sub>2<sub>) |  |
| 希尔排序 | O(n<sub>2<sub>) |  |
| 归并排序 | O(nlogn) |  |
| 快速排序 | O(nlogn) |  |
| 堆排序 | O(nlogn) |  |
| 二叉排序树排序 | O(nlogn) |  |
| 技术排序 | O(n) |  |
| 基数排序 | O(n) |  |
| 桶排序 | O(n) |  |

## 1.冒泡排序

    function bubbleSort (arr, order) {
      for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
          if ((arr[j] - arr[j + 1]) * order > 0) {
            exchange(arr, j, j + 1)
          }
        }
      }

      return arr
    }

    function exchange (arr, i, j) {
      let temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
    }

    // test
    // 1:顺序 -1:逆序
    bubbleSort([3, 1, 3, 2, 3, 9, 8, 7, 0], 1)
    bubbleSort([3, 1, 3, 2, 3, 9, 8, 7, 0], -1)

## 2.插入排序

后面每一项根据大小比较，依次插入前面已排好序的部分。

    function insertSort (arr, order) {
      let j, temp
      for (let i = 1; i < arr.length; i++) {
        j = i
        temp = arr[i]

        while(j > 0 && (arr[j-1] - temp) * order > 0) {
          arr[j] = arr[j-1]
          j--
        }

        arr[j] = temp
      }

      return arr
    }

    // test
    insertSort([3, 1, 3, 2, 3, 9, 8, 7, 0], 1)
    insertSort([3, 1, 3, 2, 3, 9, 8, 7, 0], -1)
    
## 3.选择排序



    function selectionSort (arr, order) {
      let index
      for (let i = 0; i < arr.length; i++) {
        index = i
        for (let j = i + 1; j < arr.length; j++) {
          if ((arr[index] - arr[j]) * order > 0) {
            index = j
          }
        }
        if (index !== i) {
          exchange(arr, i, index)
        }
      }

      return arr
    }

    function exchange (arr, i, j) {
      let temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
    }

    // test
    selectionSort([3, 1, 3, 2, 3, 9, 8, 7, 0], 1)
    selectionSort([3, 1, 3, 2, 3, 9, 8, 7, 0], -1)
