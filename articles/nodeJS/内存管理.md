# 内存管理

`process.memoryUsage()`可以查看进程的内存使用情况。

    ➜  ~ node
    > process.memoryUsage()
    { rss: 22302720,
      heapTotal: 7684096,
      heapUsed: 5010816,
      external: 8804 }

说明：

* `rss`进程常驻内存
* `heapTotal`为已申请的堆内存
* `heapUsed`堆内存当前使用量

进程常驻内存中，除了堆内存，还有堆外内存。堆外内存不经过V8内存分配机制，没有堆内存的大小限制。

`os.totalmem()`可以查看操作系统总内存，`os.freemem()`可以查看操作系统闲置内存。

## V8限制内存

默认情况，V8限制内存64位系统下约为1.4GB（老生代1400M，新生代32M），32位系统下约为0.7GB（老生代700M，新生代16M）。

可以通过命令行参数配置：

    node --max-old-space-size=1700 test.js // 单位为MB
    node --max-new-space-size=1024 test.js // 单位为KB

V8为什么限制内存：

* 表层原因：V8最初为浏览器设计，不太可能遇到用大量内存的场景。
* 深层原因：V8垃圾回收机制效率低。

## V8垃圾回收算法

分代垃圾回收机制，新生代Scavenge算法，老生代Mark-Sweep和Mark-Compact。

### 1.Scavenge

> Scavenge算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。

> 由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。

### 2.Mark-Sweep

> Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。

> 可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。

### 3.Mark-Compact

> Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

| **项目** | **Scavenge** | **Mark-Sweep** | **Mark-Compact** |
| :--- | :--- | :--- | :--- |
| 速度 | 最快 | 中等 | 最慢 |
| 空间开销 | 双倍空间，无碎片 | 少，有碎片 | 少，无碎片 |
| 是否移动对象 | 是 | 否 | 是 |
| 停顿 | 全停顿 | 增量标记，增量清理 | 增量整理 |

## 内存泄漏

内存泄漏的实质：应当回收的对象因为意外没有被回收，成为常驻老生代中的对象。

内存泄漏的原因：

* 缓存
* 队列消费不及时
* 变量或作用域未释放

### 1.缓存

把内存当缓存来使用。

解决方案：

* 缓存限制。限制一个缓存长度，超过数量时先进先出淘汰
* 进程外缓存。`node_redis`、`memcached`

### 2.队列消费不及时

消费速度低于生产速度，将会形成堆积。如：利用数据库记录海量日志。

解决方案：

* 表层：换用消费速度更高的技术
* 深度：监控队列长度

### 3.变量或作用域未释放

解决方案：

* 变量主动释放，赋值为`undefined/null`（`delete`可能干扰V8的优化）
* 闭包引用置空

### 排查工具

* node-heapdump
* node-memwatch
* v8-profiler
* node-mtrace
* dtrace
