# 关于闭包的应用

闭包概念：**有权访问另一个函数作用域中的变量的函数**。常见闭包形式，在一个函数内部创建另一个函数。

可以参考：[闭包原理](https://github.com/freedomcly/blog/blob/master/articles/JavaScript%E5%9F%BA%E7%A1%80/JavaScript%E5%86%85%E5%AD%98%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.md#%E9%97%AD%E5%8C%85)

## bind polyfill

    Function.prototype.bind = function(context) {
      let self = this;
      let argus1 = Array.prototype.slice.call(arguments, 1);

      return function() {
        let argus2 = Array.prototype.slice.apply(arguments);
        return self.apply(context, argus1.concat(argus2));
      }
    }
    
    // test
    function getName (){
      console.log(arguments);
      return this.name;
    }
    
    var realGetName = getName.bind({name: 233}, 11, 22);
    realGetName(33, 44, 55);


* 1.是否需要`return self.apply(...)`？
return更好一些，能拿到`return this.name`

## curry polyfill

    Function.prototype.curry = function () {
      const args = Array.prototype.slice.call(arguments)
      const self = this
      return function () {
        const innerArgs = Array.prototype.slice.call(arguments)
        const finalArgs = args.concat(innerArgs)
        return self.apply(null, finalArgs)
      }
    }

    // test
    function test(a, b, c, d, e){console.log(a,b,c,d,e)}
    var testA = test.curry(1)
    var testB = testA.curry(2, 3)
    testB(4, 5)

- [ ] 为什么要curry

## repeat

使用JS实现一个repeat方法：

    function repeat (func, times, wait) {}
    const repeatFunc = repeat(alert, 4, 3000)

调用这个repeatedFunc("hello world")，会alert4次hello world，每次间隔3秒。

    function repeat (func, times, wait) {
      let time = times;
      let self = this;
      let repeatFunc = function() {
        if(time <= 0) return;
        let argus = Array.prototype.slice.apply(arguments);
        setTimeout(() => {
          func.apply(self, argus);
          time--;
          repeatFunc(argus);
        }, wait);
      };
      return repeatFunc;
    }
    
    // test
    const repeatFunc = repeat(alert, 4, 3000);
    repeatFunc('hello world');
    
* 1.如何实现连续调用？
在repeat函数中定义具名函数repeatFunc，在repeatFunc中调用自己。
* 2.注意参数的传递。
`'hello world'`继续传递给后续的repeatFunc。

## throttle

    function throttle(func, delay) {
      let self = this;
      let timer;
      let currentArgus;
      return function() {
        // 更新为最后一次调用的参数
        currentArgus = Array.prototype.slice.apply(arguments);
        if(!timer) {
          timer = setTimeout(() => {
            func.apply(self, currentArgus);
            timer = null;
          }, delay);
        }
      }
    }

    // test
    let realFunc = throttle(console.log, 3000);
    realFunc('hello');
    realFunc('hello');
    realFunc('hello world');

注意和debounce的区别，这个[demo](https://codepen.io/llh911001/pen/XmGYKV?editors=1010)很不错。

## debounce

    function debounce(func, delay) {
      let self = this;
      let timer;
      let currentArgus;
      return function() {
        // 更新为最后一次调用的参数
        currentArgus = Array.prototype.slice.apply(arguments);
        if(timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          func.apply(self, currentArgus);
          timer = null;
        }, delay);
      }
    }
    
    // test
    let realFunc = debounce(console.log, 3000);
    realFunc('hello');
    realFunc('hello');
    realFunc('hello world');
    
