# JavaScript 深入之原型链

## 构造函数、原型对象、实例

**1. 函数的prototype属性**

    function func () {}
    console.log(func.prototype) // {constructor: ƒ}
    
每个普通函数都有`prototype`属性，指向原型对象。

原型对象是什么呢？

当函数作为构造函数使用，构造函数的实例都会与其原型对象产生联系，可以获取原型对象的属性。

    function Person () {}

    Person.prototype.name = 'Person'

    var person1 = new Person()
    var person2 = new Person()

    person1.name // Person
    person2.name // Person

构造函数的实例怎么与构造函数的prototype属性指向的原型对象产生联系呢？

**2. 对象的__proto__属性**

    var obj = {}
    obj.__proto__ // {...}

每个普通对象都有`__proto__`属性，指向其原型对象。

通过对象表达式创建的对象是`Object`的实例，因此：

    obj.__proto__ === Object.prototype // true

`__proto__`从哪里来呢？`__proto__`并不存在于实例和实例的原型对象，而是`Object.prototype`中的getter。我们访问对象的`__proto__`时，会一直追溯到`Object.prototype`中根据getter函数来返回。

**3. 原型对象的constructor属性**

构造函数和其实例有什么联系呢？换句话说，怎么获取一个对象的构造函数？

可以通过`constructor`属性：

   var obj = {}
   obj.constructor // Object
   
   function Person () {}
   var person = new Person()
   person.constructor // Person
   
实例对象`person`是空的，`person`的`constructor`从哪里获取的呢？

原来`person`的原型对象中有`constructor`属性，指向其构造函数。

   function Person () {}
   var person = new Person()
   person.constructor // Person
   person.__proto__.constructor // Person
   Person.prototype.constructor // Person
   
由此，得到了构造函数、原型对象、实例之间的关系：

...

## 原型链

